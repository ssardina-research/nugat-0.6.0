-- Automatically generated by pp2smv

MODULE system_module(env)

  VAR
    action : {
      start_action,
      pickup_b1,
      pickup_b3,
      pickup_b2,
      putdown_b1,
      putdown_b3,
      putdown_b2,
      stack_b1_b1,
      stack_b1_b3,
      stack_b1_b2,
      stack_b3_b1,
      stack_b3_b3,
      stack_b3_b2,
      stack_b2_b1,
      stack_b2_b3,
      stack_b2_b2,
      unstack_b1_b1,
      unstack_b1_b3,
      unstack_b1_b2,
      unstack_b3_b1,
      unstack_b3_b3,
      unstack_b3_b2,
      unstack_b2_b1,
      unstack_b2_b3,
      unstack_b2_b2,
      nop
    };

    last : boolean;

  INIT
    action = start_action & last = FALSE

  TRANS
    next(action) != start_action &
    (next(action=nop) <-> next(last)) &
    -- Action preconditions
    case
      next(action=pickup_b1): next(env.clear_b1) & next(env.on-table_b1) & next(env.arm-empty);
      next(action=pickup_b3): next(env.clear_b3) & next(env.on-table_b3) & next(env.arm-empty);
      next(action=pickup_b2): next(env.clear_b2) & next(env.on-table_b2) & next(env.arm-empty);
      next(action=putdown_b1): next(env.holding_b1);
      next(action=putdown_b3): next(env.holding_b3);
      next(action=putdown_b2): next(env.holding_b2);
      next(action=stack_b1_b1): next(env.clear_b1) & next(env.holding_b1);
      next(action=stack_b1_b3): next(env.clear_b3) & next(env.holding_b1);
      next(action=stack_b1_b2): next(env.clear_b2) & next(env.holding_b1);
      next(action=stack_b3_b1): next(env.clear_b1) & next(env.holding_b3);
      next(action=stack_b3_b3): next(env.clear_b3) & next(env.holding_b3);
      next(action=stack_b3_b2): next(env.clear_b2) & next(env.holding_b3);
      next(action=stack_b2_b1): next(env.clear_b1) & next(env.holding_b2);
      next(action=stack_b2_b3): next(env.clear_b3) & next(env.holding_b2);
      next(action=stack_b2_b2): next(env.clear_b2) & next(env.holding_b2);
      next(action=unstack_b1_b1): next(env.on_b1_b1) & next(env.clear_b1) & next(env.arm-empty);
      next(action=unstack_b1_b3): next(env.on_b1_b3) & next(env.clear_b1) & next(env.arm-empty);
      next(action=unstack_b1_b2): next(env.on_b1_b2) & next(env.clear_b1) & next(env.arm-empty);
      next(action=unstack_b3_b1): next(env.on_b3_b1) & next(env.clear_b3) & next(env.arm-empty);
      next(action=unstack_b3_b3): next(env.on_b3_b3) & next(env.clear_b3) & next(env.arm-empty);
      next(action=unstack_b3_b2): next(env.on_b3_b2) & next(env.clear_b3) & next(env.arm-empty);
      next(action=unstack_b2_b1): next(env.on_b2_b1) & next(env.clear_b2) & next(env.arm-empty);
      next(action=unstack_b2_b3): next(env.on_b2_b3) & next(env.clear_b2) & next(env.arm-empty);
      next(action=unstack_b2_b2): next(env.on_b2_b2) & next(env.clear_b2) & next(env.arm-empty);
      TRUE : TRUE;
    esac
    &
    -- planning program requirements: last holds on next state only if so does the pending goal
    (next(last) -> (
      (next(env.planning_program_transition=trans_3)& next(env.on_b1_b2))|
      (next(env.planning_program_transition=trans_4)& next(env.on_b2_b1))|
      (next(env.planning_program_transition=trans_5)& next(env.on_b3_b2) & next(env.on_b2_b1)))
)
-- end of system_module

MODULE environment_module(sys)

  VAR
    --domain fluents
      clear_b1 : boolean;
      clear_b3 : boolean;
      clear_b2 : boolean;
      on-table_b1 : boolean;
      on-table_b3 : boolean;
      on-table_b2 : boolean;
      arm-empty : boolean;
      holding_b1 : boolean;
      holding_b3 : boolean;
      holding_b2 : boolean;
      on_b1_b1 : boolean;
      on_b1_b3 : boolean;
      on_b1_b2 : boolean;
      on_b3_b1 : boolean;
      on_b3_b3 : boolean;
      on_b3_b2 : boolean;
      on_b2_b1 : boolean;
      on_b2_b3 : boolean;
      on_b2_b2 : boolean;

    --planning program current state
      planning_program_state : {
        start_state,
        n2,
        n1,
        n0
      };

    --pending planning program transition
      planning_program_transition : {
        start_transition,
        trans_3,
        trans_4,
        trans_5
      };

  INIT
    -- all predicates initially set to false, they are correctly initialized by start_action
      !clear_b1 & 
      !clear_b3 & 
      !clear_b2 & 
      !on-table_b1 & 
      !on-table_b3 & 
      !on-table_b2 & 
      !arm-empty & 
      !holding_b1 & 
      !holding_b3 & 
      !holding_b2 & 
      !on_b1_b1 & 
      !on_b1_b3 & 
      !on_b1_b2 & 
      !on_b3_b1 & 
      !on_b3_b3 & 
      !on_b3_b2 & 
      !on_b2_b1 & 
      !on_b2_b3 & 
      !on_b2_b2 & 
    -- planning program in dummy initial state and transition
      planning_program_state = start_state &
      planning_program_transition = start_transition
  TRANS
    -- block for fluent clear_b1
    case
      sys.action = start_action : next (clear_b1);
      sys.action = pickup_b1 : !next(clear_b1);
      sys.action = putdown_b1 : next(clear_b1);
      sys.action = unstack_b1_b1 : next(clear_b1) & !next(clear_b1);
      sys.action = stack_b1_b1 : next(clear_b1) & !next(clear_b1);
      sys.action = stack_b3_b1 : !next(clear_b1);
      sys.action = unstack_b2_b1 : next(clear_b1);
      sys.action = stack_b1_b3 : next(clear_b1);
      sys.action = stack_b1_b2 : next(clear_b1);
      sys.action = stack_b2_b1 : !next(clear_b1);
      sys.action = unstack_b1_b3 : !next(clear_b1);
      sys.action = unstack_b3_b1 : next(clear_b1);
      sys.action = unstack_b1_b2 : !next(clear_b1);
      TRUE : next(clear_b1=clear_b1);
    esac
    &    -- block for fluent clear_b3
    case
      sys.action = start_action : next (clear_b3);
      sys.action = pickup_b3 : !next(clear_b3);
      sys.action = putdown_b3 : next(clear_b3);
      sys.action = stack_b3_b3 : next(clear_b3) & !next(clear_b3);
      sys.action = stack_b3_b1 : next(clear_b3);
      sys.action = stack_b1_b3 : !next(clear_b3);
      sys.action = stack_b3_b2 : next(clear_b3);
      sys.action = unstack_b1_b3 : next(clear_b3);
      sys.action = stack_b2_b3 : !next(clear_b3);
      sys.action = unstack_b3_b1 : !next(clear_b3);
      sys.action = unstack_b3_b2 : !next(clear_b3);
      sys.action = unstack_b3_b3 : next(clear_b3) & !next(clear_b3);
      sys.action = unstack_b2_b3 : next(clear_b3);
      TRUE : next(clear_b3=clear_b3);
    esac
    &    -- block for fluent clear_b2
    case
      sys.action = start_action : next (clear_b2);
      sys.action = pickup_b2 : !next(clear_b2);
      sys.action = putdown_b2 : next(clear_b2);
      sys.action = unstack_b2_b1 : !next(clear_b2);
      sys.action = stack_b1_b2 : !next(clear_b2);
      sys.action = stack_b2_b1 : next(clear_b2);
      sys.action = stack_b3_b2 : !next(clear_b2);
      sys.action = stack_b2_b3 : next(clear_b2);
      sys.action = stack_b2_b2 : next(clear_b2) & !next(clear_b2);
      sys.action = unstack_b1_b2 : next(clear_b2);
      sys.action = unstack_b3_b2 : next(clear_b2);
      sys.action = unstack_b2_b2 : next(clear_b2) & !next(clear_b2);
      sys.action = unstack_b2_b3 : !next(clear_b2);
      TRUE : next(clear_b2=clear_b2);
    esac
    &    -- block for fluent on-table_b1
    case
      sys.action = start_action : next (on-table_b1);
      sys.action = pickup_b1 : !next(on-table_b1);
      sys.action = putdown_b1 : next(on-table_b1);
      TRUE : next(on-table_b1=on-table_b1);
    esac
    &    -- block for fluent on-table_b3
    case
      sys.action = start_action : next (on-table_b3);
      sys.action = pickup_b3 : !next(on-table_b3);
      sys.action = putdown_b3 : next(on-table_b3);
      TRUE : next(on-table_b3=on-table_b3);
    esac
    &    -- block for fluent on-table_b2
    case
      sys.action = start_action : next (on-table_b2);
      sys.action = pickup_b2 : !next(on-table_b2);
      sys.action = putdown_b2 : next(on-table_b2);
      TRUE : next(on-table_b2=on-table_b2);
    esac
    &    -- block for fluent arm-empty
    case
      sys.action = start_action : next (arm-empty);
      sys.action = pickup_b1 : !next(arm-empty);
      sys.action = pickup_b3 : !next(arm-empty);
      sys.action = pickup_b2 : !next(arm-empty);
      sys.action = putdown_b1 : next(arm-empty);
      sys.action = putdown_b3 : next(arm-empty);
      sys.action = putdown_b2 : next(arm-empty);
      sys.action = unstack_b1_b1 : !next(arm-empty);
      sys.action = stack_b1_b1 : next(arm-empty);
      sys.action = stack_b3_b3 : next(arm-empty);
      sys.action = stack_b3_b1 : next(arm-empty);
      sys.action = unstack_b2_b1 : !next(arm-empty);
      sys.action = stack_b1_b3 : next(arm-empty);
      sys.action = stack_b1_b2 : next(arm-empty);
      sys.action = stack_b2_b1 : next(arm-empty);
      sys.action = stack_b3_b2 : next(arm-empty);
      sys.action = unstack_b1_b3 : !next(arm-empty);
      sys.action = stack_b2_b3 : next(arm-empty);
      sys.action = stack_b2_b2 : next(arm-empty);
      sys.action = unstack_b3_b1 : !next(arm-empty);
      sys.action = unstack_b1_b2 : !next(arm-empty);
      sys.action = unstack_b3_b2 : !next(arm-empty);
      sys.action = unstack_b3_b3 : !next(arm-empty);
      sys.action = unstack_b2_b2 : !next(arm-empty);
      sys.action = unstack_b2_b3 : !next(arm-empty);
      TRUE : next(arm-empty=arm-empty);
    esac
    &    -- block for fluent holding_b1
    case
      sys.action = pickup_b1 : next(holding_b1);
      sys.action = putdown_b1 : !next(holding_b1);
      sys.action = unstack_b1_b1 : next(holding_b1);
      sys.action = stack_b1_b1 : !next(holding_b1);
      sys.action = stack_b1_b3 : !next(holding_b1);
      sys.action = stack_b1_b2 : !next(holding_b1);
      sys.action = unstack_b1_b3 : next(holding_b1);
      sys.action = unstack_b1_b2 : next(holding_b1);
      TRUE : next(holding_b1=holding_b1);
    esac
    &    -- block for fluent holding_b3
    case
      sys.action = pickup_b3 : next(holding_b3);
      sys.action = putdown_b3 : !next(holding_b3);
      sys.action = stack_b3_b3 : !next(holding_b3);
      sys.action = stack_b3_b1 : !next(holding_b3);
      sys.action = stack_b3_b2 : !next(holding_b3);
      sys.action = unstack_b3_b1 : next(holding_b3);
      sys.action = unstack_b3_b2 : next(holding_b3);
      sys.action = unstack_b3_b3 : next(holding_b3);
      TRUE : next(holding_b3=holding_b3);
    esac
    &    -- block for fluent holding_b2
    case
      sys.action = pickup_b2 : next(holding_b2);
      sys.action = putdown_b2 : !next(holding_b2);
      sys.action = unstack_b2_b1 : next(holding_b2);
      sys.action = stack_b2_b1 : !next(holding_b2);
      sys.action = stack_b2_b3 : !next(holding_b2);
      sys.action = stack_b2_b2 : !next(holding_b2);
      sys.action = unstack_b2_b2 : next(holding_b2);
      sys.action = unstack_b2_b3 : next(holding_b2);
      TRUE : next(holding_b2=holding_b2);
    esac
    &    -- block for fluent on_b1_b1
    case
      sys.action = unstack_b1_b1 : !next(on_b1_b1);
      sys.action = stack_b1_b1 : next(on_b1_b1);
      TRUE : next(on_b1_b1=on_b1_b1);
    esac
    &    -- block for fluent on_b1_b3
    case
      sys.action = stack_b1_b3 : next(on_b1_b3);
      sys.action = unstack_b1_b3 : !next(on_b1_b3);
      TRUE : next(on_b1_b3=on_b1_b3);
    esac
    &    -- block for fluent on_b1_b2
    case
      sys.action = stack_b1_b2 : next(on_b1_b2);
      sys.action = unstack_b1_b2 : !next(on_b1_b2);
      TRUE : next(on_b1_b2=on_b1_b2);
    esac
    &    -- block for fluent on_b3_b1
    case
      sys.action = stack_b3_b1 : next(on_b3_b1);
      sys.action = unstack_b3_b1 : !next(on_b3_b1);
      TRUE : next(on_b3_b1=on_b3_b1);
    esac
    &    -- block for fluent on_b3_b3
    case
      sys.action = stack_b3_b3 : next(on_b3_b3);
      sys.action = unstack_b3_b3 : !next(on_b3_b3);
      TRUE : next(on_b3_b3=on_b3_b3);
    esac
    &    -- block for fluent on_b3_b2
    case
      sys.action = stack_b3_b2 : next(on_b3_b2);
      sys.action = unstack_b3_b2 : !next(on_b3_b2);
      TRUE : next(on_b3_b2=on_b3_b2);
    esac
    &    -- block for fluent on_b2_b1
    case
      sys.action = unstack_b2_b1 : !next(on_b2_b1);
      sys.action = stack_b2_b1 : next(on_b2_b1);
      TRUE : next(on_b2_b1=on_b2_b1);
    esac
    &    -- block for fluent on_b2_b3
    case
      sys.action = stack_b2_b3 : next(on_b2_b3);
      sys.action = unstack_b2_b3 : !next(on_b2_b3);
      TRUE : next(on_b2_b3=on_b2_b3);
    esac
    &    -- block for fluent on_b2_b2
    case
      sys.action = stack_b2_b2 : next(on_b2_b2);
      sys.action = unstack_b2_b2 : !next(on_b2_b2);
      TRUE : next(on_b2_b2=on_b2_b2);
    esac
    &
    -- constraints for planning program
    case
    --constraints depending on actions
      sys.action = start_action : next(planning_program_state=n0);
      TRUE : TRUE;
    esac
    &
    case
    --invariant constraints 
      next(planning_program_state=n2): next(planning_program_transition=trans_5);
      next(planning_program_state=n1): next(planning_program_transition=trans_4);
      next(planning_program_state=n0): next(planning_program_transition=trans_3);
      TRUE : TRUE;
    esac
    &
    case
    --constraints depending on last
      planning_program_transition = trans_3 & sys.last : next(planning_program_state=n1);
      planning_program_transition = trans_3 & !sys.last : next(planning_program_state=planning_program_state)& next(planning_program_transition=trans_3);
      planning_program_transition = trans_4 & sys.last : next(planning_program_state=n2);
      planning_program_transition = trans_4 & !sys.last : next(planning_program_state=planning_program_state)& next(planning_program_transition=trans_4);
      planning_program_transition = trans_5 & sys.last : next(planning_program_state=n0);
      planning_program_transition = trans_5 & !sys.last : next(planning_program_state=planning_program_state)& next(planning_program_transition=trans_5);
      TRUE : TRUE;
    esac
-- end of environment_module

GAME
--- NON-DETERMINISTIC ENVIRONMENT PLAYER
PLAYER_1
  VAR
    dom : environment_module(agent);
--- CONTROLLER PLAYER ENVIRONMENT
PLAYER_2
  VAR
    agent : system_module(dom);


BUCHIGAME PLAYER_2 (agent.last)
-- end of NuGAT planning program encoding


